#!/usr/bin/env python3
#
# Copyright 2023 Andrew Symington
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import math
from sympy import atan2, asin, sin, cos, tan, sqrt, Matrix, Symbol
from sympy.abc import x, y, z

# Calibration params
tilt = Symbol("tilt")
ogeephase = Symbol("ogeephase")
ogeemag = Symbol("ogeemag")
curve = Symbol("curve")
gibpha = Symbol("gibpha")
gibmag = Symbol("gibmag")
phase = Symbol("phase")

def calc_cal_series(s):
    f = [-8.0108022e-06, 0.0028679863, 5.3685255000000001e-06, 0.0076069798000000001, 0, 0]
    m = f[0]
    a = 0
    for i in range(0, 6):
        a = a * s + m
        m = m * s + f[i]
    return m, a

def reproject_axis_gen2(X, Y, Z, axis):
    B = atan2(Z, X)
    Ydeg = tilt + (-1 if axis else 1) * math.pi / 6.
    asinArg = tan(Ydeg) * Y / sqrt(X * X + Z * Z)
    sinYdeg = sin(Ydeg)
    cosYdeg = cos(Ydeg)
    sinPart = sin(B - asin(asinArg) + ogeephase) * ogeemag
    modAsinArg = Y / sqrt(X * X + Y * Y + Z * Z) / cosYdeg
    asinOut = asin(modAsinArg)
    mod, acc = calc_cal_series(asinOut)
    BcalCurved = sinPart + curve
    asinArg2 = asinArg + mod * BcalCurved / (cosYdeg - acc * BcalCurved * sinYdeg)
    asinOut2 = asin(asinArg2)
    sinOut2 = sin(B - asinOut2 + gibpha)
    return B - asinOut2 + sinOut2 * gibmag - phase - math.pi / 2.

observation = Matrix([
    reproject_axis_gen2(x, y, -z, 0),
    reproject_axis_gen2(x, y, -z, 1)
])

subs = {
    x: 0.0,
    y: 0.1,
    z: -1.0,
    phase: 0.000169277191,
    tilt: 0.047973632812,
    curve: 0.574707031250,
    gibpha: 2.039062500000,
    gibmag: 0.000566482544,
    ogeephase: 1.857421875000,
    ogeemag: -0.277832031250
}

v = observation.evalf(subs=subs)
print("pred", v)

state = Matrix([x, y, z])
J = observation.jacobian(state)
v = J.evalf(subs=subs)
print("J", v)


# state = Matrix([x, y, z])

# J = observation.jacobian(state)

# print(J)